
# Liferay Frameworks

This chapter provides you with a brief overview of several of the essential frameworks provided by Liferay to developers. A framework, in the context of an API, is a set of APIs and configuration that is designed for an specific purpose such as enhancing your applications with a permission system, with tags, with categories, comments, etc.

This chapter will keep evolving with more information about the existing APIs and frameworks and how to use it. So look back for more information often.

## Service Builder

Service Builder is a model-driven code generation tool built by Liferay to automate the creation of interfaces and classes for database persistence and a service layer. Service Builder will generate most of the common code needed to implement find, create, update, and delete operations on the database, allowing you to focus on the higher level aspects of service design.

The service layer generated by Service Builder, has an implementation class that is responsible for retrieving and storing data classes and adding the necessary business logic around them. This layer can optionally be composed of two layers, a local service and a remote service layer. The local service contains the business logic and accesses the persistence layer. It can be invoked by client code running in the same Java Virtual Machine. The remote service usually has additional code to check security and is meant to be accessible from anywhere over the Internet or your local network. Service Builder automatically generates the code necessary to allow access to the remote services using SOAP, JSON and Java RMI.

### Define the Model

The first step in using Service Builder is to define your model classes and their attributes in a `service.xml` file. For convenience, we will define the service within the *my-greeting* portlet, although it should be placed inside a new portlet. Create a file named `service.xml` in `portlets/my-greeting-portlet/docroot/WEB-INF` within the Plugins SDK and add the following content:

    <?xml version="1.0"?>
    <!DOCTYPE service-builder PUBLIC
    "-//Liferay//DTD Service Builder 6.1.0//EN"
    "http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">
    <service-builder package-path="com.sample.portlet.library">
        <namespace>Library</namespace>
        <entity name="Book" local-service="true" remote-service="true">

            <!-- PK fields -->

            <column name="bookId" type="long" primary="true" />

            <!-- Group instance -->

            <column name="groupId" type="long" />

            <!-- Audit fields -->

            <column name="companyId" type="long" />
            <column name="userId" type="long" />
            <column name="userName" type="String" />
            <column name="createDate" type="Date" />
            <column name="modifiedDate" type="Date" />

            <!-- Other fields -->

            <column name="title" type="String" />
        </entity>
    </service-builder>

#### Overview of *service.xml*

    <service-builder package-path="com.sample.portlet.library">

This specifies the package path to which the class will be generated. In this example, classes will generate to `WEB-INF/src/com/sample/portlet/library/`

    <namespace>Library</namespace>

The namespace element must be a unique namespace for this component. Table names will be prepended with this namepace.

    <entity name="Book" local-service="true" remote-service="false">

The entity name is the database table you want to create.

    <column name="title" type="String" />

Columns specified in `service.xml` will be created in the database with a data type appropriate to the specified Java type. Accessors in the model class will automatically be generated for these attributes.

---
![tip](../../images/tip-pen-paper.png) Always consider adding two long fields called *groupId* and *companyId* to your data models. These two fields will allow your portlet to support the multi-tenancy features of Liferay so that each organization (for each portal instance) can have its own independent data.
---

### Generate the Service

Open a terminal window in your `portlets/my-greeting-portlet` directory and enter this command:

	ant build-service

The service has been generated successfully when you see BUILD SUCCESSFUL In the terminal window, you should see that a large number of files have been generated. An overview of these files is provided below:

-   Persistence

    -   `BookPersistence` - book persistence interface `@generated`

    -   `BookPersistenceImpl` - book persistence `@generated`

    -   `BookUtil` - book persistence util, instances BookPersistenceImpl `@generated`

-   Local Service

    -   **`BookLocalServiceImpl`** - local service implementation. This is the only class within the local service that you will be able to modify manually. Your business logic will be here.

    -   `BookLocalService` - local service interface `@generated`

    -   `BookLocalServiceBaseImpl` - local service base `@generated` `@abstract`

    -   `BookLocalServiceUtil` - local service util, instances `BookLocalServiceImpl` `@generated`

    -   `BookLocalServiceWrapper` - local service wrapper, wraps `BookLocalServiceImpl` `@generated`

-   Remote Service

    -   **`BookServiceImpl`** - remove service implementation. Put here the code that adds additional security checks and invokes the local service.

    -   `BookService` - remote service interface `@generated`

    -   `BookServiceBaseImpl` - remote service base `@generated` `@abstract`

    -   `BookServiceUtil` - remote service util, instances `BookServiceImpl` `@generated`

    -   `BookServiceWrapper` - remote service wrapper, wraps `BookServiceImpl` `@generated`

    -   `BookServiceSoap` - soap remote service, proxies `BookServiceUtil` `@generated`

    -   `BookSoap` - soap book model, similar to `BookModelImpl`, does not implement Book `@generated`

    -   `BookServiceHttp` - http remote service, proxies `BookServiceUtil` `@generated`

    -   `BookJSONSerializer` - json serializer, converts `Book` to JSON array `@generated`

-   Model

    -   `BookModel` - book base model interface `@generated`

    -   `BookModelImpl` - book base model `@generated`

    -   `Book` - book model interface `@generated`

    -   **`BookImpl`** - book model implementation. You can use this class to add additional methods to your model other than the auto-generated field getters and setters.

    -   `BookWrapper` - book wrapper, wraps `Book` `@generated`

Out of all of these classes only three can be manually modified: `BookLocalServiceImpl`, `BookServiceImpl` and `BookImpl`.

### Write the Local Service Class

In the file overview above, you will see that `BookLocalService` is the interface for the local service. It contains the signatures of every method in `BookLocalServiceBaseImpl` and `BookLocalServiceImpl`. `BookLocalServiceBaseImpl` contains a few automatically generated methods providing common functionality. Since this class is generated, you should never modify it, or your changes will be overwritten the next time you run Service Builder. Instead, all custom code should be placed in `BookLocalServiceImpl`.

Open the following file:

    /docroot/WEB-INF/src/com/sample/portlet/library/service/impl/BookLocalServiceImpl.java

We will add the database interaction methods to this service layer class. Add the following method to the `BookLocalServiceImpl` class:

    public Book addBook(long userId, String title)
        throws PortalException, SystemException {
        User user = UserUtil.findByPrimaryKey(userId);
        Date now = new Date();
        long bookId = CounterLocalServiceUtil.increment(Book.class.getName());

        Book book = bookPersistence.create(bookId);

        book.setTitle(title);
        book.setCompanyId(user.getCompanyId());
        book.setUserId(user.getUserId());
        book.setUserName(user.getFullName());
        book.setCreateDate(now);
        book.setModifiedDate(now);
        book.setTitle(title);

        return bookPersistence.update(book);
    }

Before you can use this new method, you must add its signature to the `BookLocalService` interface by running service builder again.

Navigate to the root directory of your portlet in the terminal and run:

    ant build-service

Service Builder looks through `BookLocalServiceImpl` and automatically copies the signatures of each method into the interface. You can now add a new book to the database by making the following call

    BookLocalServiceUtil.addBook(userId, "A new title");

### Overview of *service.properties*

Service Builder generates the properties file `service.properties` in the `src` directory of your service. Liferay Portal uses these properties to alter your service's database schema and load Spring configuration files to support deployment of your service. You should not modify this file, but rather make any necessary overrides in a `service-ext.properties` file in the `src` folder.

The only property that you may need to overwrite from this file is `build.auto.upgrade`. Setting `build.auto.upgrade=false` in your `service-ext.properties` prevents Liferay from trying to automatically apply any changes to the database model when a new version of the plugin is deployed. This is needed in projects in which it is preferred to manually manage the changes to the database or in which the SQL schema has been modified manually after generation by Service Builder.

### Built-In Liferay Services

In addition to the services you create using Service Builder, your portlets may also access a variety of services built into Liferay. These include the following:

- `UserService`

- `OrganizationService`

- `GroupService`

- `CompanyService`

- `ImageService`

- `LayoutService`

- `OrganizationService`

- `PermissionService`

- `UserGroupService`

- `RoleService`

For more information on these services, see *Liferay in Action* and Liferay's Javadocs.

## TagLib Builder (new TODO)

## Asset Framework

The asset framework provides a set of functionalities that are common to several different content types. It was initially created to be able to add tags to blog entries, wiki pages, web content, etc without having to re-implement this same functionality over and over. Since then, it has grown to include more functionalities and it has been made possible to use the framework for custom applications even if they are implemented within a plugin.

The term *asset* is used as a generic way to refer to any type of content regardless of whether it's purely text, an external file, a URL, an image, an record in an online book library, etc. From now on, whenever the word asset is used, think of it as a generic way to refer to documents, blog entries, bookmarks, wiki pages, etc.

Here are the main functionalities that you will be able to reuse thanks to the asset framework:

-   Associate tags to custom content types (new tags will be created automatically when the author assigns them to the content).

-   Associate categories to custom content types (authors will only be allowed to select from predefined categories within several predefined vocabularies)

-   Manage tags from the control panel (including merging tags)

-   Manage categories from the control panel (including creating complex hierarchies).

-   Keep track of the number of visualizations of an asset.

-   Publish your content using the Asset Publisher portlet. Asset Publisher is able to publish dynamic lists of assets or manually selected lists of assets. It is also able to show a summary view of an asset and offer a link to the full view if desired. Because of this it will save you time since for many use cases it will make it unnecessary to develop custom portlets for your custom content types.

If these functionalities seem useful for your case, then you might be wondering, what do I have to do to benefit from them?

The following subsections describe the steps involved in using the asset framework. The first one is mandatory and consists on letting the framework know whenever one of your custom content entries is added, updated or deleted. The second part is optional but can save a lot of time so most developers will probably make use of it. It consists on using a set of taglibs to provide widgets that allow authors to enter tags and categories as well as how to show the entered tags and categories along with the content. The rest of the sections are also optional but offer interesting functionalities such as how to allow your custom assets to be published through the Asset Publisher.

#### Adding, updating and deleting assets

Whenever one of your custom content is created you need to let the asset framework know. Don't worry, it is simple. You just need to invoke a method of the asset framework. When invoking this method you will also let the framework know about the tags and/or categories of the content that was just authored.

All the methods that you will need to invoke are part of the `AssetEntryLocalService`. In particular you should access these methods using either the static methods of `AssetLocalServiceUtil` or by using an instance of the `AssetEntryLocalService` injected by Spring. To make this section simpler we will be using the former, since it doesn't require any special setup in your application.

The method that you need to invoke when one of your custom content has been added or updated is the same and is called `updateEntry`. Here is the full signature:

    AssetEntry updateEntry(
            long userId, long groupId, String className, long classPK,
            String classUuid, long classTypeId, long[] categoryIds,
            String[] tagNames, boolean visible, Date startDate, Date endDate,
            Date publishDate, Date expirationDate, String mimeType,
            String title, String description, String summary, String url,
            String layoutUuid, int height, int width, Integer priority,
            boolean sync)
        throws PortalException, SystemException

Here is an example invocation of this method extracted from the blogs portlet that comes bundled with Liferay:

    assetEntryLocalService.updateEntry(
            userId, entry.getGroupId(), BlogsEntry.class.getName(),
            entry.getEntryId(), entry.getUuid(), 0, assetCategoryIds,
            assetTagNames, visible, null, null, entry.getDisplayDate(), null,
            ContentTypes.TEXT_HTML, entry.getTitle(), null, summary, null, null,
            0, 0, null, false);

Here is a quick summary of the most important parameters of this method:

-   *userId*: is the identifier of the user who created the content

-   *groupId*: identifies the scope in which the content has been created. If your content does not support scopes, you can just pass `0` as the value.

-   *className*: identifies the type of asset. By convention we recommend that it is the name of the Java class that represents your content type, but you can actually use any String you want as long as you are sure that it is unique.

-   *classPK*: identifies the specific content being created among any other of the same type. It is usually the primary key of the table where the custom content is stored. The *classUuid* parameter can optionally be used to specify a secondary identifier that is guaranteed to be universally unique. This type of identifier is especially useful if your contents will be exported and imported across separate portals.

-   *assetCategoryIds* and *assetTagNames*: represent the categories and tags that have been selected by the author of the content. The asset framework will sotre them for you.

-   *visible*: specifies whether this content should be shown at all by Asset Publisher.

-   *title,* *description* and *summary:* are descriptive fields that will be used by the Asset Publisher when displaying entries of your content type.

-   *publishDate* and *expirationDate:* can optionally be specified to let the Asset Publisher know that it should not show the content before a given publication date of after a given expiration date.

-   All other fields are optional and might not make sense to include in some cases. The *sync* parameter should always be false unless you are doing something very advanced (look at the code if you are really curious).

When one of your custom content is deleted you should also let the Asset Framework know, to clean up the information stored and also to make sure that the Asset Publisher doesn't show any information for the content that has been deleted. The signature of method to delete an asset entry is:

    void deleteEntry(String className, long classPK)

Here is an example invocation extracted again from the blogs portlet:

    assetEntryLocalService.deleteEntry(
    	BlogsEntry.class.getName(), entry.getEntryId());

#### Entering and displaying tags and categories

The previous section showed how you can let the asset framework know about the tags and categories that have been associated with a given asset; but how does a content author specify such tags and categories?

The answer is that you can choose any method that you prefer, but Liferay provides a set of JSP tags that you can use to make this task very easy. The following Liferay UI tags can be used within your forms to create content that can be associated with new/existing tags or predefined categories:

    <label>Tags</label>
    <liferay-ui:asset-tags-selector
        className="<%= entry.getClass().getName() %>"
        classPK="<%= entry.getPrimaryKey() %>"
    />

    <label>Categories</label>
        <liferay-ui:asset-categories-selector
            className="<%= entry.getClass().getName() %>"
            classPK="<%= entry.getPrimaryKey() %>"
    />

These two taglibs create appropriate form controls that allow the user to search for a tag or create a new tag, and select a existing category.

---
![tip](../../images/tip-pen-paper.png) If you are using Liferay's Alloy Form taglibs, creating fields to enter tags and categories is even simpler. You just need to use <aui:input name="tags" type="assetTags" /> and <aui:input name="categories" type="assetCategories" /> respectively.
---

Once the tags and categories have been entered you will want to show them along with the content of the asset. The following demonstrates how to display the tags and categories:

    <label>Tags</label>
    <liferay-ui:asset-tags-summary
        className="<%= entry.getClass().getName() %>"
        classPK="<%= entry.getPrimaryKey() %>"
    />

    <label>Categories</label>
    <liferay-ui:asset-categories-summary
        className="<%= entry.getClass().getName() %>"
        classPK="<%= entry.getPrimaryKey() %>"
    />

In both tags, you can also specify an optional `portletURL` parameter. Each tag that uses the `portletURL` parameter will be a link containing the `portletURL` *and* `tag` or `categoryId` parameter value respectively. This supports tags navigation and categories navigation within your portlet. But you will need to implement the look-up functionality in your portlet code by reading the values of those two parameters and using the `AssetEntryService` to query the database for entries based on the specified tag or category.

#### Publishing assets with Asset Publisher

One of the nice benefits of using the asset framework is leveraging the Asset Publisher portlet to publish lists of your custom asset types. The lists can be dynamically specified (for example, based on the asset tags or categories) by the user or statically specified by an administrator.  The Asset Publisher portlet is part of the Liferay distribution.

In order to be able to display your assets, the Asset Publisher needs to know how to access the metadata of your assets.  Additionally, you need to provide the Asset Publisher with templates for the types of views (e.g., *full* view and abstract view) available to display your assets.

You can provide all this to the Asset Publisher by implementing the following pair of interfaces - AssetRendererFactory and AssetRenderer:

-   **AssetRendererFactory:**     this class knows how to retrieve specific assets from the persistent storage via the class `classPK`. The `classPK` is typically the asset's primary  key, but can be anything you have specified to the `updateAsset` method used to add or update the asset. Your factory implementation should be able to grab the asset from a `groupId` (identifies a scope of data) and a `urlTitle` (a title that can be used in friendly URLs to refer uniquely to the asset within a given scope). Finally, the asset renderer factory can provide a URL for the Asset Publisher to use when a user wants to add a new asset of your custom type. This URL should point to your own portlet. There are other less important methods of the interface, but you can avoid implementing them by extending **BaseAssetRendererFactory**. Extending this *base* class, instead of implementing the interface directly, will make your code more robust to possible interface changes in future versions of Liferay, since the base implementation will already be updated to accommodate the interface changes.

-   **AssetRenderer:** this is the class that provides metadata information about one specific asset. It verifies whether the current user has permission to edit or view the asset. And this class is responsible for rendering the asset for the different templates (e.g. abstract and full content view) by forwarding to a specific an appropriate JSP. It is recommended that you extend the **BaseAssetRenderer**  class rather than directly implementing the interface. The *base* class provides nice defaults and robustness for methods that could be added to the interface in the future.

Let's see an example of these two classes. Again we will pick Liferay's Blogs portlet. Lets start with the implementation for the `AssetRendererFactory`:

    public class BlogsEntryAssetRendererFactory extends BaseAssetRendererFactory {

        public static final String CLASS_NAME = BlogsEntry.class.getName();

        public static final String TYPE = "blog";

        public AssetRenderer getAssetRenderer(long classPK, int type)
            throws PortalException, SystemException {

            BlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(classPK);

            return new BlogsEntryAssetRenderer(entry);
        }

        @Override
        public AssetRenderer getAssetRenderer(long groupId, String urlTitle)
            throws PortalException, SystemException {

            BlogsEntry entry = BlogsEntryServiceUtil.getEntry(groupId, urlTitle);

            return new BlogsEntryAssetRenderer(entry);
        }

        public String getClassName() {
            return CLASS_NAME;
        }

        public String getType() {
            return TYPE;
        }

        @Override
        public PortletURL getURLAdd(
                LiferayPortletRequest liferayPortletRequest,
                LiferayPortletResponse liferayPortletResponse)
            throws PortalException, SystemException {

            HttpServletRequest request =
                liferayPortletRequest.getHttpServletRequest();

            ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
                WebKeys.THEME_DISPLAY);

            if (!BlogsPermission.contains(
                themeDisplay.getPermissionChecker(),
                themeDisplay.getScopeGroupId(), ActionKeys.ADD_ENTRY)) {

                return null;
            }

        PortletURL portletURL = PortletURLFactoryUtil.create(
            request, PortletKeys.BLOGS, getControlPanelPlid(themeDisplay),
            PortletRequest.RENDER_PHASE);

            portletURL.setParameter("struts_action", "/blogs/edit_entry");

            return portletURL;
        }

        @Override
        public boolean hasPermission(
                PermissionChecker permissionChecker, long classPK, String actionId)
            throws Exception {

            return BlogsEntryPermission.contains(
                permissionChecker, classPK, actionId);
        }

        @Override
        public boolean isLinkable() {
            return _LINKABLE;
        }

        @Override
        protected String getIconPath(ThemeDisplay themeDisplay) {
            return themeDisplay.getPathThemeImages() + "/blogs/blogs.png";
        }

        private static final boolean _LINKABLE = true;
    }

And here is the AssetRenderer implementation:

    public class BlogsEntryAssetRenderer extends BaseAssetRenderer {

        public BlogsEntryAssetRenderer(BlogsEntry entry) {
            _entry = entry;
        }

        public long getClassPK() {
            return _entry.getEntryId();
        }

        @Override
        public String getDiscussionPath() {
            if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
                return "edit_entry_discussion";
            }
            else {
                return null;
            }
        }

        public long getGroupId() {
            return _entry.getGroupId();
        }

        public String getSummary(Locale locale) {
            return HtmlUtil.stripHtml(_entry.getDescription());
        }

        public String getTitle(Locale locale) {
            return _entry.getTitle();
        }

        @Override
        public PortletURL getURLEdit(
                LiferayPortletRequest liferayPortletRequest,
                LiferayPortletResponse liferayPortletResponse)
            throws Exception {

            PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
                getControlPanelPlid(liferayPortletRequest), PortletKeys.BLOGS,
                PortletRequest.RENDER_PHASE);

            portletURL.setParameter("struts_action", "/blogs/edit_entry");
            portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

            return portletURL;
        }

        @Override
        public String getUrlTitle() {
            return _entry.getUrlTitle();
        }

        @Override
        public PortletURL getURLView(
                LiferayPortletResponse liferayPortletResponse,
                WindowState windowState)
            throws Exception {

            PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
                PortletKeys.BLOGS, PortletRequest.RENDER_PHASE);

            portletURL.setWindowState(windowState);

            portletURL.setParameter("struts_action", "/blogs/view_entry");
            portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

            return portletURL;
        }

        @Override
        public String getURLViewInContext(
            LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse,
            String noSuchEntryRedirect) {

            ThemeDisplay themeDisplay =
                (ThemeDisplay)liferayPortletRequest.getAttribute(
                    WebKeys.THEME_DISPLAY);

            return themeDisplay.getPortalURL() + themeDisplay.getPathMain() +
                "/blogs/find_entry?noSuchEntryRedirect=" +
                    HttpUtil.encodeURL(noSuchEntryRedirect) + "&entryId=" +
                        _entry.getEntryId();
        }

        public long getUserId() {
            return _entry.getUserId();
        }

        public String getUuid() {
            return _entry.getUuid();
        }

        @Override
        public boolean hasEditPermission(PermissionChecker permissionChecker) {
            return BlogsEntryPermission.contains(
                permissionChecker, _entry, ActionKeys.UPDATE);
        }

        @Override
        public boolean hasViewPermission(PermissionChecker permissionChecker) {
            return BlogsEntryPermission.contains(
                permissionChecker, _entry, ActionKeys.VIEW);
        }

        @Override
        public boolean isPrintable() {
            return true;
        }

        public String render(
                RenderRequest renderRequest, RenderResponse renderResponse,
                String template)
            throws Exception {

            if (template.equals(TEMPLATE_ABSTRACT) ||
                template.equals(TEMPLATE_FULL_CONTENT)) {

                renderRequest.setAttribute(WebKeys.BLOGS_ENTRY, _entry);

                return "/html/portlet/blogs/asset/" + template + ".jsp";
            }
            else {
                return null;
            }
        }

        @Override
        protected String getIconPath(ThemeDisplay themeDisplay) {
            return themeDisplay.getPathThemeImages() + "/blogs/blogs.png";
        }

        private BlogsEntry _entry;

    }

Note that in the render method, there is a forward to a JSP in the case of the abstract and the full content templates. The abstract is not mandatory and if it is not provided, the Asset Publisher will show the title and the summary obtained through the appropriate methods of the renderer. The full content template should always be provided. Here is how it looks like for blogs entries:

    <%@ include file="/html/portlet/blogs/init.jsp" %>

    <%
    BlogsEntry entry = (BlogsEntry)request.getAttribute(WebKeys.BLOGS_ENTRY);
    %>

    <%= entry.getContent() %>

    <liferay-ui:custom-attributes-available className="<%= BlogsEntry.class.getName() %>">
        <liferay-ui:custom-attribute-list
            className="<%= BlogsEntry.class.getName() %>"
            classPK="<%= (entry != null) ? entry.getEntryId() : 0 %>"
            editable="<%= false %>"
            label="<%= true %>"
        />
    </liferay-ui:custom-attributes-available>

That's about it. It wasn't that hard, right? Now you can start enjoying the benefits of the asset framework in your custom portlets.

## ServiceContext

The ServiceContext object contains a set of fields that are common to many different services. It is used, for example to carry tags, categories, permissions information, ... It is not a framework in itself but rather a utility object that helps usage of the other frameworks.

## File Storage Framework

The File Storage Framework: Allows storing files using the back-end of the Document Library. By using this framework you won't have to worry yourself about clustering or backups since that will already be taken care of for the Document Library itself. This framework is used, for example, by the wiki and the message boards of Liferay to store attached files in pages and posts respectively. You can check the source code of these two portlets for great real-life examples of how to use the framework.

### Document Types (new TODO)

### CMIS Repository / Third Party Repository Hooks (new TODO)

## Other frameworks

Liferay has a wide variety of frameworks that make it much easier to develop complex functionalities for your own applications with little effort. These frameworks have evolved from the applications bundled with Liferay out of the box so they have been proven in the real world, even in very high performance portals.

This chapter is a placeholder that provides a quick description to the main frameworks provided with Liferay 6. Note that what follows is a work in progress since more sections will be added over time and some of the current sections will evolve into its own chapter as we add more information and detailed instructions on how to use them over time.

-   Workflow Framework: Allows adding Workflow functionality to your own portlets. One great benefit of using this framework is that you will be able to reuse all of the workflow management UIs provided by Liferay. Also you will be able to abstract your code from the specific workflow engine that will be used (JBPM, Liferay Kaleo, ...). Many Liferay portlets use this framework. If you want a simple example to learn how to use it, the blogs portlet is a good start.

-   Comments Framework: Allows adding comments easily in any portlet without any database code. Many Liferay portlets use this functionality, for example the blogs portlet for the comments of each entry.

-   Custom fields: A portlet that uses custom fields will allow the end user to extend the fields of its data entries with custom ones defined by the end user. To see a list of data types in Liferay that support this functionality just go to the Control Panel -\> Custom Fields.

-   Report abuse: Allow end users to report that some information published in a page should not be there.

-   Inline permissions Framework: Allows enhancing your SQL queries so that the database takes care of checking for view permissions. This is particularly useful when doing queries for data entries that could result in a large number of items (and thus checking of permissions afterward would be very inefficient) or when you want to implement pagination (which would not work fine if permissions are checked afterward and an item is removed). The Document Library or the Message Boards of Liferay are examples of portlets that use this functionality.

Check in the near future for new editions of the Developer's Guide for extended information on each of these frameworks.

