# Creating Remote Services with Service Builder

Earlier, you used Service Builder to generate the model, persistence, and
service layers of your app. The services generated by Service Builder come in
two flavors: local and remote. Local services, as their name implies, can only
be invoked locally. This means that they're invoked from the JVM in which
Liferay is running. Remote services can be invoked by an application outside of
Liferay's JVM. They're designed for use by any web client that has permission
to access them. The remote services generated by Service Builder are published
as JSON web services when your application is deployed. You can also use
Service Builder to generate a WSDL (Web Services Description Language) document
for your remote services to make them available via SOAP (Simple Object Access
Protocol).

For more information, 
[click here](/develop/tutorials/-/knowledge_base/7-0/service-builder-web-services) 
to see the Service Builder Web Services section of tutorials. 

To examine the Liferay web services that are currently available on your portal, 
navigate to `http://[host name]:[port number]/api/jsonws` 
([http://localhost:8080/api/jsonws](http://localhost:8080/api/jsonws) 
if you're running @product@ locally on port 8080). By default, this page lists 
the web service methods in the `portal` context. To view an app's web services, 
select the app's context path in the *Context Path* menu. For example, to view 
the Calendar app's web services, select `calendar` in the *Context Path* menu. 
Once you add remote services to the Guestbook app, you'll be able to access 
them from the app's context path. 

To specify whether Service Builder should generate local services, remote 
services, or both, you must add the appropriate entries to your app's 
`service.xml` file. Open your `guestbook-service` module's `service.xml` file 
and examine the tags for the `Guestbook` and `Entry` entities: 

    <entity name="Guestbook" local-service="true" uuid="true">

    <entity name="Entry" local-service="true" uuid="true">

As described in the `service.xml` 
[DTD](https://docs.liferay.com/ce/portal/7.0-ga3/definitions/), 
`local-service` defaults to `false` and `remote-service` defaults to `true`. 
However, it's best to specify explicitly whether Service Builder should 
generate local and remote services. Other developers who read your 
`service.xml` file might not know or remember the defaults. Therefore, add 
`remote-service="true"` to the entity tags of the `Guestbook` and `Entry` 
entities: 

    <entity name="Guestbook" local-service="true" remote-service="true" uuid="true">

    <entity name="Entry" local-service="true" remote-service="true" uuid="true">

In the *Gradle Tasks* window on the right-hand side of Liferay IDE, expand your 
service module's build folder. Run Service Builder by double-clicking 
*buildService*. When Service Builder finishes, refresh the `guestbook-api` and 
`guestbook-service` modules in the Project Explorer. 

You're probably wondering what, exactly, Service Builder just did. Recall that
earlier, you exposed access to the app's persistence layer by adding methods to
the `*LocalServiceImpl` classes generated by Service Builder. In the
`guestbook-service` module, these classes are `GuestbookLocalServiceImpl` and
`EntryLocalServiceImpl`. Service Builder generated them initially, but after
that didn't touch them. You implemented your local service layer in them.
Similarly, running Service Builder with `remote-service="true"` set on your
entities generates `*ServiceImpl` classes in which you must implement your
remote service layer. In the `guestbook-service` module, these classes are
`GuestbookServiceImpl` and `EntryServiceImpl`. To get remote services working
for the Guestbook app, use the following steps:

1. Create a new class in the `com.liferay.docs.guestbook.util` package called
   `ActionKeys`. Add the following code to this class:

        package com.liferay.docs.guestbook.util;

        public class ActionKeys extends
                        com.liferay.portal.kernel.security.permission.ActionKeys {

                public static final String ADD_ENTRY = "ADD_ENTRY";
                public static final String ADD_GUESTBOOK = "ADD_GUESTBOOK";
        }

    The `ADD_ENTRY` and `ADD_GUESTBOOK` strings are used to reference the 
    permissions that you defined in the `guestbook-service` module's 
    `docroot/WEB-INF/src/resource-actions/default.xml` file in an earlier 
    section of this learning path. It's a best practice to create strings to 
    refer to your permissions in a class called `ActionKeys` that extends 
    `com.liferay.portal.kernel.security.permission.ActionKeys`. The latter 
    `ActionKeys` contains strings that are used to refer to portal permissions. 
    These include strings for common permissions such as `VIEW`, `UPDATE`, 
    `DELETE`, and so on. 

2. Open the `GuestbookServiceImpl` class and add the following methods: 

        public Guestbook addGuestbook(long userId, String name,
            ServiceContext serviceContext) throws SystemException,
            PortalException {

            return guestbookLocalService.addGuestbook(userId, name, serviceContext);
        }

        public Guestbook deleteGuestbook(long guestbookId,
            ServiceContext serviceContext) throws PortalException,
            SystemException {

            return guestbookLocalService.deleteGuestbook(guestbookId, serviceContext);
        }

        public List<Guestbook> getGuestbooks(long groupId) throws SystemException {
                return guestbookLocalService.getGuestbooks(groupId);
        }

        public List<Guestbook> getGuestbooks(long groupId, int start, int end)
                        throws SystemException {
                return guestbookLocalService.getGuestbooks(groupId, start, end);
        }

        public int getGuestbooksCount(long groupId) throws SystemException {
                return guestbookLocalService.getGuestbooksCount();
        }

        public Guestbook updateGuestbook(long userId, long guestbookId,
            String name, ServiceContext serviceContext) throws PortalException,
            SystemException {

            return guestbookLocalService.updateGuestbook(userId, guestbookId,
                name, serviceContext);
        }

    Here, you add a remote service method for each existing guestbook local 
    service method. For now, the remote service method implementations simply 
    call the local service implementations. By @product@ convention, however, 
    permission checking is added in remote service implementations, because 
    users calling those services aren't calling them from the app's UI (which 
    already has permission checks). Since they're bypassing the UI and going 
    directly to the services, you have to check to see if they have permission 
    to access the data they're trying to access before you give it to them. 
    You'll implement permission checking in the next section. For now, you just 
    want to create remote services, confirm that they're accessible, and confirm 
    that they work. 

3. Open the `EntryServiceImpl` class and add the following methods: 

        public Entry addEntry(long userId, long guestbookId, String name,
                String email, String message, ServiceContext serviceContext)
                throws PortalException, SystemException {

            return entryLocalService.addEntry(userId, guestbookId, name, email,
                         message, serviceContext);
        }

        public Entry deleteEntry(long entryId, ServiceContext serviceContext)
                        throws PortalException, SystemException {

            return entryLocalService.deleteEntry(entryId, serviceContext);
        }

        public List<Entry> getEntries(long groupId, long guestbookId)
                        throws SystemException {

            return entryLocalService.getEntries(groupId, guestbookId);
        }

        public List<Entry> getEntries(long groupId, long guestbookId, int start,
                        int end) throws SystemException {

            return entryLocalService.getEntries(groupId, guestbookId, start, end);
        }

        public int getEntriesCount(long groupId, long guestbookId)
                        throws SystemException {

            return entryLocalService.getEntriesCount(groupId, guestbookId);
        }

        public Entry updateEntry(long userId, long guestbookId, long entryId,
                        String name, String email, String message,
                        ServiceContext serviceContext) throws PortalException,
                        SystemException {

            return entryLocalService.updateEntry(userId, guestbookId, entryId,
                                name, email, message, serviceContext);
        }

    Here, you're doing the same thing for guestbook entries that you did for
    guestbooks in step 2. You're creating skeleton remote service methods that 
    correspond to existing local service methods. The remote service methods 
    call the local service methods. You'll add permission checks in the next
    section. 

4. Run Service Builder and redeploy the `guestbook-*` modules. 

Now navigate to @product@'s JSONWS page 
(`http://[host name]:[port number]/api/jsonws`) and click the *Context Path* 
selector. The Guestbook app's context, `gb`, now appears as an option. Select 
it and confirm that your remote service methods appear in the list. 

![Figure 1: After you've added remote service methods to your project's `*ServiceImpl` classes, run Service Builder and redeploy your modules. Then check that your remote services are accessible.](../../../images/jsonws-guestbook.png)

To test that your remote services are working, choose a method to invoke. Pick
a simple method that does not require a Service Context parameter, like
`getGuestbooksCount(long groupId)`. To find the appropriate `groupId` (the ID
of the site containing the Guestbook app), navigate to that site in your
browser and select *Configuration* &rarr; *Site Settings* from the Site Menu on
the left. The site ID is listed at the top of the Site Settings page. Now
return to the JSONWS page and enter the site ID into the group ID field and
click *Invoke*. Confirm that the correct number of guestbooks is returned.
Great! Your remote web services are working.

Next, you'll build a WSDD (Web Service Deployment Descriptor) document for your
remote services to make them available via SOAP (Simple Object Access Protocol). 

Follow these steps to do so:

1. In your Liferay workspace's `settings.gradle` file, add imports for 
   `ServiceBuilderPlugin` and `WSDDBuilderPlugin`. Then add the 
   `gradle.beforeProject` closure at the bottom of the file: 

        import com.liferay.gradle.plugins.service.builder.ServiceBuilderPlugin
        import com.liferay.gradle.plugins.wsdd.builder.WSDDBuilderPlugin

        ...

        gradle.beforeProject {
            project ->

            project.plugins.withType(ServiceBuilderPlugin) {
                project.apply plugin: WSDDBuilderPlugin
            }
        }

    Refresh your workspace's Gradle files by right clicking `settings.gradle` in 
    the Project Explorer and then selecting *Gradle* &rarr; *Refresh Gradle 
    Project*. 

2. In the `guestbook-service` module's `build.gradle` file, add the following 
   inside `dependencies{...}`: 

        compileOnly group: "com.liferay", name: "com.liferay.registry.api", version: "1.0.0"
        compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
        compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"

3. In the *Gradle Tasks* window on the right-hand side of Liferay IDE, expand 
   your service module's build folder. Build the WSDD by double-clicking 
   *buildWSDD*. 

In the `guestbook-service` module's `build/libs` folder, the WSDD build
generates `guestbook.service-wsdd-1.0.0.jar`. This JAR file contains the WSDD
and WSDL files. To access your app's SOAP web services, you must deploy this
JAR file to your @product@ instance. Do so now by copying and pasting the file
into your @product@ instance's `deploy` folder. When the deploy completes,
navigate to `http://[host name]:[port number]/o/guestbook.service/api/axis` in
your browser to view the Guestbook app's SOAP web services. If you're running
@product@ locally on port 8080, this is
[http://localhost:8080/o/guestbook.service/api/axis](http://localhost:8080/o/guestbook.service/api/axis). 

This page contains links to the WSDL (Web Services Description Language) 
documents for the Guestbook and Entry remote service methods. WSDL files 
describe details about the remote service methods, including the type of data 
that these methods handle. 

If you'd like to make your app's services available for remote invocation via 
SOAP, generating WSDD and WSDL files is required. For example, 
[the Liferay Mobile SDK](https://web.liferay.com/community/liferay-projects/liferay-mobile-sdk/overview) 
relies on the WSDD and WSDL to discover your @product@ app's remote services. 
For the Liferay Mobile SDK to create a mobile client that can access your 
@product@ app's web services, you must therefore generate a WSDD and WSDL for 
your app. 

Next, you'll learn how to secure your web services. Unless you secure your web
services by implementing permission checks, any user can add, update, or delete
guestbooks or guestbook entries, and you certainly don't want that. 
